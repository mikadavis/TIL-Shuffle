<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIL Shuffle - Concurrent Submission Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 40px;
            max-width: 900px;
            margin: 0 auto;
        }
        h1 { color: #00f2fe; }
        h2 { color: #f093fb; margin-top: 30px; }
        .test-section {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 10px 10px 0;
        }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .success { color: #43e97b; }
        .error { color: #ff4757; }
        .warning { color: #ffa502; }
        .info { color: #00f2fe; }
        #log {
            background: #000;
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 13px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .log-entry { margin: 4px 0; }
        input {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 10px;
            border-radius: 6px;
            width: 300px;
            margin: 5px 0;
        }
        label { display: block; margin-top: 10px; color: #b8c1ec; }
    </style>
</head>
<body>
    <h1>ğŸ§ª TIL Shuffle - Concurrent Submission Test</h1>
    <p>This test simulates multiple users submitting TILs concurrently to verify the Structured Memories API fix.</p>

    <div class="test-section">
        <h2>Step 1: API Key</h2>
        <p>Enter your API key (same one used in TIL Shuffle):</p>
        <input type="text" id="apiKey" placeholder="Paste your API key here...">
        <button onclick="saveApiKey()">Save API Key</button>
        <span id="apiKeyStatus"></span>
    </div>

    <div class="test-section">
        <h2>Step 2: Create Test Game</h2>
        <p>Create a new game for testing:</p>
        <button onclick="createTestGame()">Create New Test Game</button>
        <div id="gameInfo"></div>
    </div>

    <div class="test-section">
        <h2>Step 3: Simulate Concurrent Submissions</h2>
        <p>Simulate multiple users submitting TILs at the same time:</p>
        <label>Number of concurrent users:</label>
        <input type="number" id="numUsers" value="5" min="2" max="20">
        <br>
        <button onclick="runConcurrentTest()" id="runTestBtn">ğŸš€ Run Concurrent Test</button>
        <button onclick="verifyResults()" id="verifyBtn">âœ… Verify All Entries Saved</button>
    </div>

    <div class="test-section">
        <h2>Test Log</h2>
        <button onclick="clearLog()">Clear Log</button>
        <div id="log"></div>
    </div>

    <script>
        const API_BASE_URL = 'https://api.wearables-ape.io';
        const STORAGE_KEY_PREFIX = 'til-shuffle-game-';
        let currentGameId = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type;
            logDiv.innerHTML += `<div class="log-entry ${colorClass}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function getApiKey() {
            return document.getElementById('apiKey').value.trim() || localStorage.getItem('ape-api-key');
        }

        function saveApiKey() {
            const key = document.getElementById('apiKey').value.trim();
            if (key) {
                localStorage.setItem('ape-api-key', key);
                document.getElementById('apiKeyStatus').innerHTML = '<span class="success">âœ“ Saved!</span>';
                log('API key saved to localStorage', 'success');
            } else {
                document.getElementById('apiKeyStatus').innerHTML = '<span class="error">Please enter a key</span>';
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function createTestGame() {
            const apiKey = getApiKey();
            if (!apiKey) {
                log('ERROR: No API key found. Please enter your API key first.', 'error');
                return;
            }

            log('Creating new test game...', 'info');

            currentGameId = generateUUID();
            const recordId = `${STORAGE_KEY_PREFIX}${currentGameId}`;

            const gameData = {
                gameId: currentGameId,
                createdAt: new Date().toISOString(),
                lastUpdated: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                entries: []
            };

            try {
                const response = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gameData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }

                log(`âœ“ Test game created successfully!`, 'success');
                log(`  Game ID: ${currentGameId}`, 'info');
                log(`  Record ID: ${recordId}`, 'info');

                document.getElementById('gameInfo').innerHTML = `
                    <p class="success">âœ“ Game Created!</p>
                    <p><strong>Game ID:</strong> <code>${currentGameId}</code></p>
                `;

            } catch (error) {
                log(`ERROR creating game: ${error.message}`, 'error');
            }
        }

        async function simulateUserSubmission(userId, gameId) {
            const apiKey = getApiKey();
            const recordId = `${STORAGE_KEY_PREFIX}${gameId}`;
            const userName = `TestUser${userId}`;
            const tilText = `Test TIL from ${userName} - submitted at ${new Date().toISOString()}`;

            // Generate unique entry ID BEFORE any API calls
            const entryId = generateUUID();

            log(`[User ${userId}] Starting submission for ${userName} (entry ID: ${entryId.substring(0, 8)}...)`, 'info');

            const maxRetries = 5;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    // Step 1: Load existing entries
                    log(`[User ${userId}] Attempt ${attempt}: Loading existing entries...`, 'info');
                    const loadResponse = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    let existingData = { entries: [] };
                    if (loadResponse.ok) {
                        const data = await loadResponse.json();
                        existingData = data.value || data;
                    }
                    const existingEntries = existingData.entries || [];
                    log(`[User ${userId}] Found ${existingEntries.length} existing entries`, 'info');

                    // Step 2: Create new entry with pre-generated ID
                    const newEntry = {
                        id: entryId,
                        til: tilText,
                        name: userName,
                        isRevealed: false,
                        timestamp: new Date().toISOString()
                    };

                    // Step 3: Merge entries (deduplicate by ID)
                    const entriesMap = new Map();
                    existingEntries.forEach(entry => {
                        if (entry.id) entriesMap.set(entry.id, entry);
                    });
                    entriesMap.set(newEntry.id, newEntry);
                    const mergedEntries = Array.from(entriesMap.values());

                    log(`[User ${userId}] Merged entries count: ${mergedEntries.length}`, 'info');

                    // Step 4: Save merged entries
                    const gameData = {
                        ...existingData,
                        gameId: gameId,
                        lastUpdated: new Date().toISOString(),
                        entries: mergedEntries
                    };

                    const saveResponse = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(gameData)
                    });

                    if (!saveResponse.ok) {
                        throw new Error(`HTTP ${saveResponse.status}: ${await saveResponse.text()}`);
                    }

                    // Step 5: VERIFY - Read back and check if our entry exists
                    log(`[User ${userId}] Verifying save...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 200)); // Small delay

                    const verifyResponse = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (verifyResponse.ok) {
                        const verifyData = await verifyResponse.json();
                        const savedEntries = (verifyData.value || verifyData).entries || [];
                        const ourEntryExists = savedEntries.some(e => e.id === entryId);

                        if (ourEntryExists) {
                            log(`[User ${userId}] âœ“ Entry verified! Save successful.`, 'success');
                            return { success: true, userId, userName };
                        } else {
                            log(`[User ${userId}] âš  Entry NOT found after save! Retrying...`, 'warning');
                            if (attempt < maxRetries) {
                                const delay = 500 * Math.pow(2, attempt - 1) + Math.random() * 500;
                                await new Promise(resolve => setTimeout(resolve, delay));
                                continue; // Retry
                            }
                        }
                    }

                    // If we get here without verification, consider it success (fallback)
                    log(`[User ${userId}] âœ“ Save completed (verification skipped)`, 'success');
                    return { success: true, userId, userName };

                } catch (error) {
                    log(`[User ${userId}] Attempt ${attempt} failed: ${error.message}`, 'error');
                    if (attempt === maxRetries) {
                        return { success: false, userId, error: error.message };
                    }
                    const delay = 500 * Math.pow(2, attempt - 1);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            return { success: false, userId, error: 'Max retries exceeded' };
        }

        async function runConcurrentTest() {
            if (!currentGameId) {
                log('ERROR: Please create a test game first!', 'error');
                return;
            }

            const numUsers = parseInt(document.getElementById('numUsers').value);
            if (numUsers < 2 || numUsers > 20) {
                log('ERROR: Number of users must be between 2 and 20', 'error');
                return;
            }

            document.getElementById('runTestBtn').disabled = true;

            log('', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log(`ğŸš€ STARTING CONCURRENT TEST WITH ${numUsers} USERS`, 'warning');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log('', 'info');

            // Launch all submissions CONCURRENTLY (no await between them)
            const startTime = Date.now();
            const promises = [];

            for (let i = 1; i <= numUsers; i++) {
                // Add a tiny random delay (0-100ms) to simulate real-world slight timing differences
                const delay = Math.random() * 100;
                promises.push(
                    new Promise(resolve => setTimeout(resolve, delay))
                        .then(() => simulateUserSubmission(i, currentGameId))
                );
            }

            log(`All ${numUsers} submissions launched concurrently!`, 'warning');

            // Wait for all to complete
            const results = await Promise.all(promises);

            const endTime = Date.now();
            const duration = (endTime - startTime) / 1000;

            log('', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log(`ğŸ“Š TEST COMPLETED in ${duration.toFixed(2)} seconds`, 'warning');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');

            const successful = results.filter(r => r.success).length;
            const failed = results.filter(r => !r.success).length;

            log(`Successful submissions: ${successful}/${numUsers}`, successful === numUsers ? 'success' : 'warning');
            if (failed > 0) {
                log(`Failed submissions: ${failed}/${numUsers}`, 'error');
            }

            log('', 'info');
            log('Now click "Verify All Entries Saved" to check the final count!', 'warning');

            document.getElementById('runTestBtn').disabled = false;
        }

        async function verifyResults() {
            if (!currentGameId) {
                log('ERROR: No test game to verify!', 'error');
                return;
            }

            const apiKey = getApiKey();
            const recordId = `${STORAGE_KEY_PREFIX}${currentGameId}`;

            log('', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log('ğŸ” VERIFYING SAVED ENTRIES', 'warning');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');

            try {
                const response = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }

                const data = await response.json();
                const gameData = data.value || data;
                const entries = gameData.entries || [];

                log(`Total entries saved: ${entries.length}`, entries.length > 0 ? 'success' : 'error');
                log('', 'info');

                if (entries.length > 0) {
                    log('Saved entries:', 'info');
                    entries.forEach((entry, index) => {
                        log(`  ${index + 1}. ${entry.name}: "${entry.til.substring(0, 50)}..."`, 'info');
                    });
                }

                const numUsers = parseInt(document.getElementById('numUsers').value);
                log('', 'info');

                if (entries.length === numUsers) {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                    log(`âœ… SUCCESS! All ${numUsers} entries were saved correctly!`, 'success');
                    log('The Structured Memories API fix is WORKING!', 'success');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                } else if (entries.length < numUsers) {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                    log(`âŒ FAILURE! Only ${entries.length} of ${numUsers} entries were saved!`, 'error');
                    log(`Missing entries: ${numUsers - entries.length}`, 'error');
                    log('There is still a race condition issue!', 'error');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                } else {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
                    log(`âš ï¸ More entries than expected: ${entries.length} vs ${numUsers}`, 'warning');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
                }

            } catch (error) {
                log(`ERROR verifying: ${error.message}`, 'error');
            }
        }

        // Load API key from localStorage on page load
        window.onload = function() {
            const savedKey = localStorage.getItem('ape-api-key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                log('API key loaded from localStorage', 'info');
            }
            log('Test page ready. Create a test game to begin.', 'info');
        };
    </script>
</body>
</html>
