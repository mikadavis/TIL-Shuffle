<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIL Shuffle - Concurrent Submission Test (Conflict-Free)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 40px;
            max-width: 900px;
            margin: 0 auto;
        }
        h1 { color: #00f2fe; }
        h2 { color: #f093fb; margin-top: 30px; }
        .test-section {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 10px 10px 0;
        }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .success { color: #43e97b; }
        .error { color: #ff4757; }
        .warning { color: #ffa502; }
        .info { color: #00f2fe; }
        #log {
            background: #000;
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 13px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .log-entry { margin: 4px 0; }
        input {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 10px;
            border-radius: 6px;
            width: 300px;
            margin: 5px 0;
        }
        label { display: block; margin-top: 10px; color: #b8c1ec; }
        .architecture-info {
            background: rgba(67, 233, 123, 0.1);
            border-left: 4px solid #43e97b;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª TIL Shuffle - Concurrent Submission Test</h1>
    <p>This test simulates multiple users submitting TILs concurrently using the <strong>conflict-free architecture</strong>.</p>

    <div class="architecture-info">
        <strong>âœ… Conflict-Free Architecture:</strong>
        <ul>
            <li>Each participant saves to their <strong>OWN separate record</strong> (no conflicts possible!)</li>
            <li>Main game record only stores list of participant session IDs</li>
            <li>When loading, we aggregate all participant records</li>
        </ul>
    </div>

    <div class="test-section">
        <h2>Step 1: API Key</h2>
        <p>Enter your API key (same one used in TIL Shuffle):</p>
        <input type="text" id="apiKey" placeholder="Paste your API key here...">
        <button onclick="saveApiKey()">Save API Key</button>
        <span id="apiKeyStatus"></span>
    </div>

    <div class="test-section">
        <h2>Step 2: Create Test Game</h2>
        <p>Create a new game for testing:</p>
        <button onclick="createTestGame()">Create New Test Game</button>
        <div id="gameInfo"></div>
    </div>

    <div class="test-section">
        <h2>Step 3: Simulate Concurrent Submissions</h2>
        <p>Simulate multiple users submitting TILs at the same time:</p>
        <label>Number of concurrent users:</label>
        <input type="number" id="numUsers" value="5" min="2" max="20">
        <br>
        <button onclick="runConcurrentTest()" id="runTestBtn">ğŸš€ Run Concurrent Test</button>
        <button onclick="verifyResults()" id="verifyBtn">âœ… Verify All Entries Saved</button>
    </div>

    <div class="test-section">
        <h2>Test Log</h2>
        <button onclick="clearLog()">Clear Log</button>
        <div id="log"></div>
    </div>

    <script>
        const API_BASE_URL = 'https://api.wearables-ape.io';
        const GAME_RECORD_PREFIX = 'til-shuffle-game-';
        const PARTICIPANT_RECORD_PREFIX = 'til-shuffle-participant-';
        let currentGameId = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type;
            logDiv.innerHTML += `<div class="log-entry ${colorClass}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function getApiKey() {
            return document.getElementById('apiKey').value.trim() || localStorage.getItem('ape-api-key');
        }

        function saveApiKey() {
            const key = document.getElementById('apiKey').value.trim();
            if (key) {
                localStorage.setItem('ape-api-key', key);
                document.getElementById('apiKeyStatus').innerHTML = '<span class="success">âœ“ Saved!</span>';
                log('API key saved to localStorage', 'success');
            } else {
                document.getElementById('apiKeyStatus').innerHTML = '<span class="error">Please enter a key</span>';
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function saveToRecord(recordId, data) {
            const apiKey = getApiKey();
            const response = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }
            return await response.json();
        }

        async function loadFromRecord(recordId) {
            const apiKey = getApiKey();
            const response = await fetch(`${API_BASE_URL}/structured-memories/${recordId}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                if (response.status === 404) {
                    return { notFound: true, data: null };
                }
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }
            const result = await response.json();
            return { notFound: false, data: result.value || result };
        }

        async function createTestGame() {
            const apiKey = getApiKey();
            if (!apiKey) {
                log('ERROR: No API key found. Please enter your API key first.', 'error');
                return;
            }

            log('Creating new test game with conflict-free architecture...', 'info');

            currentGameId = generateUUID();
            const gameRecordId = `${GAME_RECORD_PREFIX}${currentGameId}`;

            const gameData = {
                gameId: currentGameId,
                createdAt: new Date().toISOString(),
                lastUpdated: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                registeredParticipants: [] // List of session IDs
            };

            try {
                await saveToRecord(gameRecordId, gameData);

                log(`âœ“ Test game created successfully!`, 'success');
                log(`  Game ID: ${currentGameId}`, 'info');
                log(`  Game Record: ${gameRecordId}`, 'info');

                document.getElementById('gameInfo').innerHTML = `
                    <p class="success">âœ“ Game Created!</p>
                    <p><strong>Game ID:</strong> <code>${currentGameId}</code></p>
                    <p><strong>Architecture:</strong> Conflict-Free (each user has their own record)</p>
                `;

            } catch (error) {
                log(`ERROR creating game: ${error.message}`, 'error');
            }
        }

        async function simulateUserSubmission(userId, gameId) {
            const apiKey = getApiKey();
            const sessionId = generateUUID(); // Each user gets their own unique session
            const userName = `TestUser${userId}`;
            const tilText = `Test TIL from ${userName} - submitted at ${new Date().toISOString()}`;
            const entryId = generateUUID();

            log(`[User ${userId}] Starting submission (session: ${sessionId.substring(0, 8)}...)`, 'info');

            try {
                // Step 1: Save entries to participant's OWN record (NO CONFLICTS!)
                const participantRecordId = `${PARTICIPANT_RECORD_PREFIX}${gameId}-${sessionId}`;
                const participantData = {
                    sessionId: sessionId,
                    gameId: gameId,
                    updatedAt: new Date().toISOString(),
                    entries: [{
                        id: entryId,
                        til: tilText,
                        name: userName,
                        isRevealed: false,
                        timestamp: new Date().toISOString()
                    }]
                };

                log(`[User ${userId}] Step 1: Saving to OWN record: ${participantRecordId.substring(0, 40)}...`, 'info');
                await saveToRecord(participantRecordId, participantData);
                log(`[User ${userId}] âœ“ Entries saved to personal record!`, 'success');

                // Step 2: Register session ID with the game (with retry)
                log(`[User ${userId}] Step 2: Registering with game...`, 'info');
                await registerParticipant(gameId, sessionId, userId);

                log(`[User ${userId}] âœ“ Complete! Entry saved and registered.`, 'success');
                return { success: true, userId, userName, sessionId };

            } catch (error) {
                log(`[User ${userId}] âœ— ERROR: ${error.message}`, 'error');
                return { success: false, userId, error: error.message };
            }
        }

        async function registerParticipant(gameId, sessionId, userId, maxRetries = 5) {
            const gameRecordId = `${GAME_RECORD_PREFIX}${gameId}`;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    // Load current game data
                    const result = await loadFromRecord(gameRecordId);
                    if (result.notFound) {
                        throw new Error('Game not found');
                    }

                    const gameData = result.data;
                    const participants = gameData.registeredParticipants || [];

                    // Check if already registered
                    if (participants.includes(sessionId)) {
                        log(`[User ${userId}] Already registered`, 'info');
                        return;
                    }

                    // Add our session ID
                    gameData.registeredParticipants = [...participants, sessionId];
                    gameData.lastUpdated = new Date().toISOString();

                    // Save updated game data
                    await saveToRecord(gameRecordId, gameData);

                    // Verify registration
                    await new Promise(resolve => setTimeout(resolve, 200));
                    const verifyResult = await loadFromRecord(gameRecordId);
                    const verifiedParticipants = verifyResult.data?.registeredParticipants || [];

                    if (verifiedParticipants.includes(sessionId)) {
                        log(`[User ${userId}] âœ“ Registration verified!`, 'success');
                        return;
                    } else {
                        log(`[User ${userId}] Registration not verified, retrying...`, 'warning');
                    }
                } catch (error) {
                    log(`[User ${userId}] Registration attempt ${attempt} failed: ${error.message}`, 'warning');
                }

                if (attempt < maxRetries) {
                    const delay = 500 * Math.pow(2, attempt - 1) + Math.random() * 500;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            // Even if registration fails, entries are still saved in participant's own record!
            log(`[User ${userId}] Registration failed but entries are safe!`, 'warning');
        }

        async function runConcurrentTest() {
            if (!currentGameId) {
                log('ERROR: Please create a test game first!', 'error');
                return;
            }

            const numUsers = parseInt(document.getElementById('numUsers').value);
            if (numUsers < 2 || numUsers > 20) {
                log('ERROR: Number of users must be between 2 and 20', 'error');
                return;
            }

            document.getElementById('runTestBtn').disabled = true;

            log('', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log(`ğŸš€ CONFLICT-FREE CONCURRENT TEST WITH ${numUsers} USERS`, 'warning');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log('Each user saves to their OWN record - NO CONFLICTS POSSIBLE!', 'info');
            log('', 'info');

            // Launch all submissions CONCURRENTLY
            const startTime = Date.now();
            const promises = [];

            for (let i = 1; i <= numUsers; i++) {
                // Add a tiny random delay (0-50ms) to simulate real-world timing
                const delay = Math.random() * 50;
                promises.push(
                    new Promise(resolve => setTimeout(resolve, delay))
                        .then(() => simulateUserSubmission(i, currentGameId))
                );
            }

            log(`All ${numUsers} submissions launched concurrently!`, 'warning');

            // Wait for all to complete
            const results = await Promise.all(promises);

            const endTime = Date.now();
            const duration = (endTime - startTime) / 1000;

            log('', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log(`ğŸ“Š TEST COMPLETED in ${duration.toFixed(2)} seconds`, 'warning');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');

            const successful = results.filter(r => r.success).length;
            const failed = results.filter(r => !r.success).length;

            log(`Successful submissions: ${successful}/${numUsers}`, successful === numUsers ? 'success' : 'warning');
            if (failed > 0) {
                log(`Failed submissions: ${failed}/${numUsers}`, 'error');
            }

            log('', 'info');
            log('Now click "Verify All Entries Saved" to check the final count!', 'warning');

            document.getElementById('runTestBtn').disabled = false;
        }

        async function verifyResults() {
            if (!currentGameId) {
                log('ERROR: No test game to verify!', 'error');
                return;
            }

            log('', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log('ğŸ” VERIFYING SAVED ENTRIES (Aggregating all participant records)', 'warning');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');

            try {
                // Step 1: Load game record to get registered participants
                const gameRecordId = `${GAME_RECORD_PREFIX}${currentGameId}`;
                const gameResult = await loadFromRecord(gameRecordId);

                if (gameResult.notFound) {
                    log('Game not found!', 'error');
                    return;
                }

                const participants = gameResult.data.registeredParticipants || [];
                log(`Registered participants: ${participants.length}`, 'info');

                // Step 2: Load each participant's entries
                const allEntries = [];
                for (const sessionId of participants) {
                    const participantRecordId = `${PARTICIPANT_RECORD_PREFIX}${currentGameId}-${sessionId}`;
                    log(`Loading participant: ${sessionId.substring(0, 8)}...`, 'info');

                    try {
                        const participantResult = await loadFromRecord(participantRecordId);
                        if (!participantResult.notFound && participantResult.data?.entries) {
                            allEntries.push(...participantResult.data.entries);
                            log(`  Found ${participantResult.data.entries.length} entries`, 'success');
                        }
                    } catch (error) {
                        log(`  Failed to load: ${error.message}`, 'error');
                    }
                }

                log('', 'info');
                log(`Total entries aggregated: ${allEntries.length}`, allEntries.length > 0 ? 'success' : 'error');

                if (allEntries.length > 0) {
                    log('Saved entries:', 'info');
                    allEntries.forEach((entry, index) => {
                        log(`  ${index + 1}. ${entry.name}: "${entry.til.substring(0, 50)}..."`, 'info');
                    });
                }

                const numUsers = parseInt(document.getElementById('numUsers').value);
                log('', 'info');

                if (allEntries.length === numUsers) {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                    log(`âœ… SUCCESS! All ${numUsers} entries were saved correctly!`, 'success');
                    log('The conflict-free architecture is WORKING!', 'success');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                } else if (allEntries.length < numUsers) {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                    log(`âŒ FAILURE! Only ${allEntries.length} of ${numUsers} entries found!`, 'error');
                    log(`Missing entries: ${numUsers - allEntries.length}`, 'error');
                    log('Note: Entries may exist but registration failed. Check participant records.', 'warning');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                } else {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
                    log(`âš ï¸ More entries than expected: ${allEntries.length} vs ${numUsers}`, 'warning');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
                }

            } catch (error) {
                log(`ERROR verifying: ${error.message}`, 'error');
            }
        }

        // Load API key from localStorage on page load
        window.onload = function() {
            const savedKey = localStorage.getItem('ape-api-key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                log('API key loaded from localStorage', 'info');
            }
            log('Test page ready (Conflict-Free Architecture).', 'info');
            log('Each participant saves to their OWN record - NO race conditions!', 'success');
        };
    </script>
</body>
</html>
